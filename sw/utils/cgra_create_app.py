#!/usr/bin/env python3
"""
CGRA Application Scaffolding Tool
Generated for HEEPsilon.

Automates the creation of a CGRA application from a CSV instruction file.
1. Analyzes CSV to detect LWD/SWD/SWI usage.
2. Generates main.c with correct pointer configuration.
3. Generates bitstream (using the advanced generator).
"""

import os
import sys
import shutil
import csv
import argparse
import re

# Template for main.c
MAIN_C_TEMPLATE = """/*
 * {app_name} - Generated by cgra_create_app.py
 */

#include <stdio.h>
#include <stdlib.h>

#include "csr.h"
#include "hart.h"
#include "handler.h"
#include "core_v_mini_mcu.h"
#include "rv_plic.h"
#include "rv_plic_regs.h"
#include "heepsilon.h"
#include "cgra.h"
#include "cgra_bitstream.h"

// Check CGRA size
#if CGRA_N_COLS != 4 || CGRA_N_ROWS != 4
  #error This example requires a 4x4 CGRA
#endif

volatile int8_t cgra_intr_flag;

// Input Data
// If SWI is used, we inject the result address at index 0.
// Otherwise, standard input data.
{input_data_section}

// Output Data
#define MAX_OUTPUTS 16
int32_t result[MAX_OUTPUTS] __attribute__((aligned(4))) = {{0}};

void handler_irq_cgra(uint32_t id) {{
    cgra_intr_flag = 1;
}}

int main(void) {{
    printf("=== {app_name} ===\\n");
    
    // Address Injection for SWI
    {swi_injection_code}
    
    // Init Context Memory
    cgra_cmem_init(cgra_cmem_bitstream, cgra_kmem_bitstream);
    
    // Init Interrupts
    plic_Init();
    plic_irq_set_priority(CGRA_INTR, 1);
    plic_irq_set_enabled(CGRA_INTR, kPlicToggleEnabled);
    plic_assign_external_irq_handler(CGRA_INTR, (void*)&handler_irq_cgra);
    
    // Enable Global Interrupts
    CSR_SET_BITS(CSR_REG_MSTATUS, 0x8);
    CSR_SET_BITS(CSR_REG_MIE, 1 << 11);
    cgra_intr_flag = 0;
    
    cgra_t cgra;
    cgra.base_addr = mmio_region_from_addr((uintptr_t)CGRA_PERIPH_START_ADDRESS);
    
    cgra_wait_ready(&cgra);
    cgra_perf_cnt_enable(&cgra, 1);
    
    // --- CGRA Pointer Configuration ---
    {pointer_config_code}
    // ----------------------------------
    
    printf("Launching CGRA kernel...\\n");
    cgra_set_kernel(&cgra, 1); // Kernel ID 1
    
    cgra_intr_flag = 0;
    while (cgra_intr_flag == 0) {{
        wait_for_interrupt();
    }}
    printf("CGRA kernel completed.\\n");
    
    // Print Outputs
    printf("CGRA outputs (first 8):\\n");
    for (int i = 0; i < 8; i++) {{
        printf("  [%d]: %ld (0x%08lx)\\n", i, (long)result[i], (unsigned long)result[i]);
    }}
    
    // Performance Counters
    printf("Cycles: %d\\n", cgra_perf_cnt_get_col_active(&cgra, 0));
    
    return EXIT_SUCCESS;
}}
"""

def analyze_csv(csv_path):
    """
    Scans the CSV to find which columns utilize LWD, SWD, or SWI.
    Returns a dict with sets of columns for each op.
    """
    analysis = {
        'lwd_cols': set(),
        'swd_cols': set(),
        'swi_cols': set()
    }
    
    with open(csv_path, 'r') as f:
        reader = csv.reader(f)
        for line in reader:
            # Skip empty or cycle-only lines
            if not line: continue
            if len(line) > 0 and line[0].strip().isdigit() and all(not x.strip() for x in line[1:]):
                continue
            
            # Helper to check op in a cell string
            for col_idx, cell in enumerate(line):
                # Simple heuristic: look for opcodes in string
                cell = cell.upper()
                if "LWD" in cell: analysis['lwd_cols'].add(col_idx)
                if "SWD" in cell: analysis['swd_cols'].add(col_idx)
                if "SWI" in cell: analysis['swi_cols'].add(col_idx)

    return analysis

def create_app(csv_path, app_name, output_base, custom_inputs=None, offsets_str=None, split_inputs=False, memory_file=None, load_addrs_str=None, store_addrs_str=None, visualize=False):
    app_dir = os.path.join(output_base, app_name)
    utils_dir = os.path.join(app_dir, "utils")
    
    if os.path.exists(app_dir):
        print(f"Warning: Directory {app_dir} already exists. Overwriting.")
    else:
        os.makedirs(app_dir)
    os.makedirs(utils_dir, exist_ok=True)
    
    # 1. Analyze Logic
    print(f"Analyzing {csv_path}...")
    analysis = analyze_csv(csv_path)
    print(f"  LWD Columns: {analysis['lwd_cols']}")
    print(f"  SWD Columns: {analysis['swd_cols']}")
    print(f"  SWI Columns: {analysis['swi_cols']}")
    
    is_swi_used = len(analysis['swi_cols']) > 0
    
    # 2. Parse Configurations
    # 2a. Inputs (Default Data)
    input_values_list = ["10", "20", "30", "-1"]
    if custom_inputs:
        input_values_list = [x.strip() for x in custom_inputs.split(',') if x.strip()]
        if input_values_list and input_values_list[-1] != "-1":
            input_values_list.append("-1")

    # 2b. Offsets
    offsets_map = {}
    if offsets_str:
        for pair in offsets_str.split(','):
            if ':' in pair:
                col, off = pair.split(':')
                offsets_map[int(col.strip())] = int(off.strip())

    # 2c. Memory File
    memory_values = []
    if memory_file:
        if os.path.exists(memory_file):
            print(f"Reading memory file: {memory_file}")
            with open(memory_file, 'r') as f:
                content = f.read().replace('\\n', ',')
                memory_values = [x.strip() for x in content.split(',') if x.strip()]
        else:
            print(f"ERROR: Memory file {memory_file} not found.")

    # 2d. Absolute Addresses
    load_addrs_map = {}
    if load_addrs_str:
        for pair in load_addrs_str.split(','):
            if ':' in pair:
                col, addr = pair.split(':')
                load_addrs_map[int(col.strip())] = addr.strip()
                
    store_addrs_map = {}
    if store_addrs_str:
        for pair in store_addrs_str.split(','):
            if ':' in pair:
                col, addr = pair.split(':')
                store_addrs_map[int(col.strip())] = addr.strip()

    # 3. Prepare main.c content
    variable_declarations = ""
    swi_code = ""
    ptr_config = ""
    
    primary_buffer_name = "input_data"
    
    if memory_values:
        mem_str = ", ".join(memory_values)
        variable_declarations += f"// Memory from {os.path.basename(memory_file)}\nint32_t cgra_memory[] __attribute__((aligned(4))) = {{{mem_str}}};\n"
        primary_buffer_name = "cgra_memory"
    
    if not memory_values or custom_inputs:
        # Generate input_data
        if is_swi_used and not "0" in input_values_list[0] and not split_inputs:
             input_values_list.insert(0, "0")
             
        if split_inputs:
             for col in analysis['lwd_cols']:
                input_str = ", ".join(input_values_list)
                variable_declarations += f"// Input for Column {col}\nint32_t input_col_{col}[] __attribute__((aligned(4))) = {{{input_str}}};\n"
        else:
            shared_input_str = ", ".join(input_values_list)
            variable_declarations += f"// Shared Input Data\nint32_t input_data[] __attribute__((aligned(4))) = {{{shared_input_str}}};\n"
            
    # SWI Injection
    if is_swi_used:
        target_buf = "cgra_memory" if memory_values else "input_data"
        swi_code = f"{target_buf}[0] = (int32_t)result; // Inject Address for SWI"
        ptr_config += f"// [AUTO] SWI Detected. Result address injected at {target_buf}[0].\n"
        primary_buffer_name = target_buf

    
    # --- Read Pointers Configuration ---
    for col in analysis['lwd_cols']:
        # Priority 1: Absolute Address
        if col in load_addrs_map:
            ptr_config += f"    cgra_set_read_ptr(&cgra, (uint32_t){load_addrs_map[col]}, {col});\n"
            continue
            
        # Priority 2: Split Inputs
        if split_inputs and not memory_values:
             ptr_config += f"    cgra_set_read_ptr(&cgra, (uint32_t)input_col_{col}, {col});\n"
             continue

        # Priority 3: Shared Buffer
        off = offsets_map.get(col, 0)
        base_ptr = f"(uint32_t){primary_buffer_name}"
        if off > 0:
            ptr_val = f"({base_ptr} + {off*4})" # Word offset assuming int32
            # Wait, pointer arithmetic on (int32_t*) moves 4 bytes.
            # But we cast to uint32_t (address) first? 
            # If we cast to uint32_t, +1 means +1 byte.
            # cgra_set_read_ptr takes uint32_t address.
            # We should probably use: (uint32_t)(array + offset)
            # which is: (uint32_t)(&array[offset])
            # Or if C logic: (uint32_t)array + offset*4.
            # My current code generates: (uint32_t)input_data + X
            # If generated code is: `(uint32_t)input_data + 4`, that adds 4 to the address.
            # So `offset` in my arg should be BYTES or WORDS?
            # User said: `1:4` meant index 1? (4 bytes).
            # I used `off*4` in one place and `off` in another (in previous flawed edit).
            # Let's standardize: CLI offsets are INDICES (Words).
            ptr_val = f"(uint32_t)({primary_buffer_name} + {off})" # Best C way: &array[off]
        else:
            ptr_val = base_ptr
            
        ptr_config += f"    cgra_set_read_ptr(&cgra, {ptr_val}, {col});\n"

    # --- Write Pointers Configuration ---
    for col in analysis['swd_cols']:
        if col in store_addrs_map:
            ptr_config += f"    cgra_set_write_ptr(&cgra, (uint32_t){store_addrs_map[col]}, {col});\n"
        else:
            ptr_config += f"    cgra_set_write_ptr(&cgra, (uint32_t)result, {col});\n"

    # Fill Template
    main_c = MAIN_C_TEMPLATE.format(
        app_name=app_name,
        input_data_section=variable_declarations,
        swi_injection_code=swi_code,
        pointer_config_code=ptr_config
    )
    
    # 3. Write Files
    with open(os.path.join(app_dir, "main.c"), "w") as f:
        f.write(main_c)
        
    shutil.copy(csv_path, os.path.join(app_dir, "instructions.csv"))
    
    # Copy Generator
    gen_src = "sw/utils/generate_bitstream.py"
    if not os.path.exists(gen_src):
        print(f"ERROR: Centralized generator not found at {gen_src}")
    else:
        shutil.copy(gen_src, os.path.join(utils_dir, "generate_bitstream.py"))
    
    # 4. Visualization (Phase 10)
    if visualize:
        print("Generating kernel visualization...")
        viz_script = "sw/utils/visualize_kernel.py"
        if os.path.exists(viz_script):
            dot_path = "kernel.dot" # Relative to app_dir since we cd inside? No, we run from here.
            # Use absolute or relative to Cwd?
            # We copy files to app_dir.
            # Let's create dot in app_dir.
            full_dot_path = os.path.join(app_dir, "kernel.dot")
            # We need to run viz_script. 
            # Pass CSV from app_dir.
            app_csv = os.path.join(app_dir, "instructions.csv")
            os.system(f"python3 {viz_script} {app_csv} {full_dot_path}")
            print(f"  Visualization saved to: {full_dot_path}")
            print("  View with: dot -Tpng kernel.dot -o kernel.png")
        else:
            print(f"Warning: Visualization script not found at {viz_script}")

    print(f"Created application frame in {app_dir}")
    
    # 5. Run Generator
    print("Generating bitstream...")
    ret = os.system(f"cd {app_dir} && python3 utils/generate_bitstream.py instructions.csv -o cgra_bitstream.h")
    
    if ret == 0:
        print("\\nDONE! To run:")
        print(f"  make verilator-run-app PROJECT={app_name}")
    else:
        print("\\nWARNING: Bitstream generation failed.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Create CGRA App Scaffolding")
    parser.add_argument("csv", help="Path to instructions.csv")
    parser.add_argument("name", help="Name of the new application")
    parser.add_argument("-i", "--inputs", help="Comma-separated input values (e.g. '5,10,15')")
    parser.add_argument("--offsets", help="Col:Offset pairs (Word Count, e.g. '0:0,1:2')")
    parser.add_argument("--split-inputs", action="store_true", help="Generate independent input arrays per column")
    parser.add_argument("--memory-file", help="Path to CSV file with memory values")
    parser.add_argument("--load-addrs", help="Col:AbsAddr pairs (e.g. '0:0x2000')")
    parser.add_argument("--store-addrs", help="Col:AbsAddr pairs (e.g. '1:0x3000')")
    parser.add_argument("--visualize", action="store_true", help="Generate kernel.dot visualization")
    args = parser.parse_args()
    
    create_app(args.csv, args.name, "sw/applications", 
               custom_inputs=args.inputs, 
               offsets_str=args.offsets, 
               split_inputs=args.split_inputs,
               memory_file=args.memory_file,
               load_addrs_str=args.load_addrs,
               store_addrs_str=args.store_addrs,
               visualize=args.visualize)
